%!TEX root = ../main.tex

\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Multi-agent Coverage}
\label{chapter:multi-agent_coverage}

In this section, we introduce the multi-agent coverage problem and our solution. Before that, we review some of the existing works in literature.


\section{Problem Statement}
\label{sec:multi_problem_statement}

First, the general multi-agent coverage problem statement is developed. Observe that a team of robots that is tasked with coverage may have robots with different dynamics and coverage footprints. In other words, a robot $i$ has its corresponding set of feasible paths $P_i$, which is not necessarily equal to that of other robots. Moreover, each robot may have a unique corresponding coverage map $\mathcal{M}_i$. As a consequence, each robot may have a unique coverable space show as a Minkowski sum:
\begin{equation}
	\mathcal{C}_i=P_i\oplus \mathcal{M}_i.
\end{equation}
Since these sets may not necessarily be the same between all robots, there are some regions in the workspace that are only accessible by certain robots. This complicates the path planning process. As a simplifying assumption, we make sure that if a point on the workspace is coverable by robot $i$, it is coverable by all other robots on the team. This could be achieved by either assuming that all robots have equal coverable space or by only considering the coverable space defined as follows:
\begin{equation}
	\mathbb{C}=\bigcap_{i=1,\ldots,n}\mathcal{C}_i.
\end{equation}

As such, the general problem is stated in Problem~\ref{problem:distr_cpp}.

\begin{problem}[Multi-agent Coverage Path Planning]
\label{problem:distr_cpp}
	Given a workspace $W$, $n$ robots with dynamics and corresponding coverage maps $\mathcal{M}_i$, compute a set of $n$ paths with the following conditions
	\begin{equation}
	\begin{aligned}
		& \{p_i\in P_{i}\ |\ i=1,\dots,n\},\\
		%& \bigcup_{i=1,\dots,n}(\bigcup_{q\in p_i}\mathcal{M}_i(q))=\mathbb{C},\\
		& \bigcup_{i=1,\dots,n}(p_i\oplus\mathcal{M}_i)=\mathbb{C},\\
		%& \sum_{i=1.\dots,n}\mathcal{E}_i(p_i)\text{ is minimized}.
		& \max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}\text{ is minimized.}
	\end{aligned}
	\end{equation}
\end{problem}

Problem~\ref{problem:distr_cpp} shares some similarities with the single agent coverage problem introduced in Chapter~\ref{chapter:single_robot_coverage}. However, there are several noticeable differences. %
% First, an assumption is made that the team of robots exhibits same dynamics. This assumption is in place to ensure that the coverable space is equivalent between all robots[UNLESS DISTRIBUTED APPROACH WHEN PARTITIONING THE WORKSPACE????].
The conditions now require that the union of $n$ paths footprints covers the entire coverable area. Another important difference is the objective of the problem. Where as in the single agent case, the objective was to minimize the cost of the path, with this problem, the objective is minimize the cost of the path with the maximum cost amongst $n$ robots. There are several motivations for this. When a team of robots performs a task, it is often undesirable when one robot finishes its assigned task much later than the other robots. This means that the rest of the team is idle while the robot is performing its task. This results in unnecessarily long duration for the whole coverage task. It is more desirable to redistribute the work of the robot with the longest duration amongst the team of robots such that the duration of the whole coverage task is reduced. In other words, amongst the team of robots, one would like to minimize the task with the longest duration.

We take a similar heuristic based approach to this problem. First, we constrict the set of feasible paths to a set of segmented feasible paths. As such, the problem statement is modified as shown in Problem~\ref{problem:distr_cpp_with_lines}.

\begin{problem}[Multi-agent Coverage Path Planning with Straight Line Segments]
\label{problem:distr_cpp_with_lines}
	Given a workspace $W$, $n$ robots with dynamics and corresponding coverage map $\mathcal{M}_i$, compute a set of $n$ paths with the following conditions
such that
	\begin{equation}
	\begin{aligned}
		& \{p_i\in P_{\text{segmented},i}\ |\ i=1,\dots,n\},\\
		& \bigcup_{i=1,\dots,n}(\bigcup_{q\in p_i}\mathcal{M}_i(q))=\mathbb{C},\text{ and}\\
		%& \sum_{i=1.\dots,n}\mathcal{E}_i(p_i)\text{ is minimized}.
		& \max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}\text{ is minimized.}
	\end{aligned}
	\end{equation}
\end{problem}

Notice in Problem~\ref{problem:distr_cpp_with_lines}, a path for each robot is computed. A robot $i$ traversing a path $p_i$ covers a region $w_i$. Formally, $w_i$ is defined as follows:
\begin{equation}
	\bigcup_{q\in p_i}\mathcal{M}(q) = w_i,\ p_i\in P_{\text{segmented},i}
\end{equation}

By conditions stated in Problem~\ref{problem:distr_cpp_with_lines}, a team of robots has to entirely cover the coverable area. Therefore, the following condition has to be met.
\begin{equation}
	\label{eq:partition_condition}
	\bigcup_{i=1,\ldots,n}w_i=\mathbb{C}
\end{equation}

Notice that condition (\ref{eq:partition_condition}) suggests some sort of decomposition of $\mathbb{C}$. Suppose a decomposition of $\mathbb{C}$ is given with a guarantee that $\max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}$ is minimized provided that all $p_i$ have the lowest possible cost. Then the only thing left to do is to compute $n$ lowest cost paths for each cell in the decomposition. This suggests that Problem~\ref{problem:distr_cpp_with_lines} could be solved via a decoupled approach that involves two steps. First step is to compute a partition of $\mathbb{C}$. Second step is to compute a minimum cost path for each cell in the partition. The first problem is stated in Problem~\ref{problem:workspace_partitioning}. The second step involves a problem that has been covered in Chapter~\ref{chapter:single_robot_coverage}.

% As such, the following problem and Problem~\ref{problem:distr_cpp_with_lines} are equivalent.
%\begin{problem}[]
%\label{problem:distr_cpp_with_lines_ii}
%	Given a workspace $W$, $n$ robots with dynamics and corresponding coverage map $\mathcal{M}_i$, compute
%	\begin{equation}
%	\begin{aligned}
%		&\{w_1,w_2,\ldots,w_n\},\\
%		&\{p_1,p_2,\ldots,p_n\}
%	\end{aligned}
%	\end{equation}
%	such that
%	\begin{equation}
%	\begin{aligned}
%		&i)& \bigcup_{i=1,\dots,n}(w_i)=\mathbb{C},\\
%		&iii) &\{p_i\in P_{\text{segmented},i}\ |\ i=1,\dots,n\},\\
%		&ii)&p_i\in w_i,\\
%		&ii)& \max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}\text{ is minimized,}\\
%		%& \sum_{i=1.\dots,n}\mathcal{E}_i(p_i)\text{ is minimized}.
%		&iv)&\mathcal{E}_i(p_i)\leq\mathcal{E}_i(p_j), \forall p_j\in P_{\text{segmented},i}\\
%	\end{aligned}
%	\end{equation}
%\end{problem}
%However, Problem~\ref{problem:distr_cpp_with_lines_ii} can be solved via a decoupled approach by solving two separate problems. The first problem deals with an optimal decomposition of the workspace. The second problem deals with computing the lowest cost paths for each cell in the decomposition. The first problem is shown in Problem~\ref{problem:workspace_partitioning} while the second problem is just an invocation of Problem~\ref{problem:min_cost_cpp_with_lines} $n$ times. The solution to that problem is covered in Chapter~\ref{chapter:single_robot_coverage}.

\begin{problem}[Workspace Partitioning based on Robot Capabilities]
\label{problem:workspace_partitioning}
	Given a workspace $W$ and $n$ robots with dynamics, compute a partitioning of $\mathbb{C}$ into $\{w_1,w_2,\dots,w_n\}$ such that
	\begin{equation}
	\begin{aligned}
		& \bigcup_{i=1,\dots,n}w_i=\mathbb{C}\text{ and}\\
		& \max_{i=1,\ldots,n}\{\chi_i(w_i)\}\text{ is minimized.}
		%& \sum_{i=1,\dots,n}\chi(w_i,q_i)\text{ is minimized}.
	\end{aligned}
	\end{equation}
\end{problem}
In this problem statement, a metric $\chi$ is designed to reflect the cost of the path computed by the solution proposed in Chapter~\ref{chapter:single_robot_coverage}. The computation of this metric is shown in later sections.


\section{Area Allocation Algorithm}
\label{sec:area_allocation_algo}
In this section, we introduce our solution to Problem~\ref{problem:workspace_partitioning} introduced in the previous section. We begin with a brief overview of the algorithm.

The main idea behind the algorithm is to converge to a suboptimal solution greedily. An initial solution to act as a starting point for the optimization is fed to the algorithm. The algorithm then performs an iterative pair-wise re-optimization procedure until the cost of the solution converges. The result is a partition with minimized maximum cost. 

As an input, $\mathbb{C}$ is provided with the assumption that it is polygonal. A set of $n$ initial positions of $n$ robots is also provided as one of the inputs. As an initialization step, the polygon $\mathbb{C}$ is partitioned into $n$ subregions of equal area by the anchored area partitioning algorithm. This step is designed to provide our algorithm  with a starting point to be used in the iterative re-optimization procedure. This initial partition acts as a good approximation of an optimal solution. In fact, many existing works model the area as being directly proportional to the work that a robot has to do.

An adjacency graph is computed on the resultant partition. For every cell in the partition, the cost of complete coverage is computed using our metric. For every cell with the highest cost, we perform the following re-optimization steps. First, some adjacent cell is picked[MAYBE CELLWITH LOWEST COST]. This pair of adjacent cells is recombined resulting in one region. A procedure is performed that greedily computes an optimal cut that generates two cells and that minimizes the maximum cost of coverage of two cells. The cost and the partition are modified accordingly. The loop is repeated for the next cell with the highest cost in the decomposition. The termination condition for this loops is when the maximum cost over all cells in the decomposition stops decreasing. Algorithm~\ref{alg:optimization_procedure} demonstrates the described procedure.

\begin{algorithm}
	%\small
	\caption{$\operatorname{optimization\_procedure}(P, S)$}
	\label{alg:optimization_procedure}
	\begin{algorithmic}[1]
		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$, Set of starting locations $S=\{s_1,\ldots,s_n\}$
			%\STATE $V\gets n$ virtual starting locations placed randomly on the boundary of $P$ \label{line:1_start_locs}
			\STATE $D\gets$ anchored\_area\_partition$(P,S,\frac{1}{n})$ \label{line:area_part}
			\STATE $M\gets$ compute $\chi(s_i,p_i), \forall p_i\in D$ 
			%\STATE Add all cells in $D$ to the queue $Q$
			\STATE $\mathcal{G}\gets$ adjacency graph of $D$
			\REPEAT
				\STATE Pop $p_i$ from $D$ with highest $\chi(s_i,p_i)$
				\STATE Pick some adjacent $p_j$
				\STATE $p_{\operatorname{temp}}\gets p_i\cup p_j$
				%\STATE $\mathbb{E}\gets$ \text{compute\_encirclements}$(p_{\operatorname{temp}})$ \label{line:compute_encirlment}
				\STATE $p'_i,p'_j\gets$ anchored\_area\_partition($p_{\text{temp}},s_i,\chi$) \label{line:distr_opt_cut}
				%\STATE $\sigma_{\ell}\gets$ compute\_encirclements($p_{\ell}$) \label{line:recalc_encirclemnts_1}
				%\STATE $\sigma_r\gets$ compute\_encirclements($p_r$) \label{line:recalc_encirclemnts_2}
				%\STATE $\sigma_{\ell}\gets$ recalc\_encirclements($p_{\ell},\mathbb{E}, c$) \label{line:recalc_encirclemnts_1}
				%\STATE $\sigma_r\gets$ recalc\_encirclements($p_r, \mathbb{E}, c$) \label{line:recalc_encirclemnts_2}
				%\STATE Cost $\gets\chi(s_i,p_{\ell},\sigma_{\ell})+\phi(s_j,p_r,\sigma_r$) 
				%\STATE Cost $\gets\max\{\chi(s_i,p_{\ell}),\chi(s_j,p_r)\}$ 
				%\STATE Implement $c$ that resulted in lowest cost, modify $D$.
				\STATE Modify $\chi(s_j,p_j)$ and $\chi(s_i,p_i)$ accordingly
				\STATE Modify $D$ with $p_i,p_j$
			\UNTIL{Maximum $\chi(s_j,p_j)$ stops decreasing}
			\RETURN $D$
	\end{algorithmic}
\end{algorithm}

Throughout the algorithm, many references are made for the metric. This metric is introduces in the next section. Algorithm~\ref{alg:optimization_procedure} makes use of several procedures that will be explained next. On Line~\ref{line:area_part},\ref{line:distr_opt_cut}, a procedure called anchored area partition is called. This procedure is based on the work by Hert~\cite{hert1998polygon} and his approach to area partitioning problem. The procedure is summarizes in Algorithm~\ref{alg:anchored_area_partition}. This algorithm allows for making cuts without having to discretized the coverable area. Moreover, a series of cuts are made to form $n$ cells with area specified by the area vector $A$. This algorithm is particularly useful since it can be modified to make cuts such that the end polygons have certain cost instead of specified area. For brevity, we only show the algorithm for convex polygons. However, Hert~\cite{hert1998polygon} does introduce an extended version of the algorithm that works on concave polygons as well.

\begin{algorithm}
	\caption{$\operatorname{anchored\_area\_partition}(P, S, A)$}
	\label{alg:anchored_area_partition}
	\begin{algorithmic}[1]
		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$, Set of starting locations $S=\{s_1,\ldots,s_n\}$, Vector of Areas $A$
		\STATE do area partition from Hert
		\RETURN $D$
	\end{algorithmic}
\end{algorithm}

%In Algorithm~\ref{alg:optimization_procedure}, in Line~\ref{line:compute_encirlment}, a procedure is called to compute \emph{encirclements}. The procedure for computing them is shown in Algorithm~\ref{alg:compute_contours}.
%\begin{algorithm}
%	\small
%	\caption{$\operatorname{compute\_encirclements}$}
%	\label{alg:compute_contours}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$
%		\STATE $\mathcal{C}\gets\emptyset$ 
%		\REPEAT
%			\STATE $C\gets$ \textit{parallel\_offset\_inwards}$(P)$
%			\STATE $\mathcal{C}\gets C$
%		\UNTIL{No further shrinking possible}
%		\RETURN $\mathcal{C}$
%	\end{algorithmic}
%\end{algorithm}
%
%The Algorithm~\ref{alg:update_contours} shows a procedure for recalculating the number of encirclements to avoid constant re-computation of contours. This increases the efficiency of the algorithm.
%\begin{algorithm}
%	\small
%	\caption{$\operatorname{recalc\_encirclements}$}
%	\label{alg:update_contours}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$, Set of contours $\mathbb{E}$, cut $c$
%		\STATE $\mathcal{C}\gets\emptyset$ 
%		\REPEAT
%			\STATE $C\gets$ \textit{parallel\_offset\_inwards}$(P)$
%			\STATE $\mathcal{C}\gets C$
%		\UNTIL{Shrinking results in a point or line}
%		\RETURN $\mathcal{C}$
%	\end{algorithmic}
%\end{algorithm}


\section{Path Planning Algorithm}
It should be noted that once Algorithm~\ref{alg:optimization_procedure} is finished and a partition is generated, then each robot has been assigned a task in a suboptimal way. Then it becomes a problem of planning a coverage path for single robot. For this, it is sufficient to run the algorithm introduces in previous section $n$ times for $n$ robots for achieve the final coverage paths.


\section{Metric}
\label{sec:metric}

In this section, we introduce and analyze the partition metric used to solve Problem~\ref{problem:workspace_partitioning}.

The key idea behind the metric is that the metric must reflect the cost of the solution to the minimum cost single robot coverage problem without explicitly computing the path. Moreover, this metric should be computed quickly since it will be used in a search algorithm. We believe that there are three components that contribute to the cost. These components are: the distance from the starting location of the robot to its assigned region, the area of the assigned region, and an approximation of the turn content of the region as a function of the robot's dynamics. These components are studied in the coming sections separately. The overall metric looks as follows.

\begin{definition}[Partition Metric]
Given a polygonal workspace $W$ and a robot with dynamics, the partition metric $\chi:W,Q\to\mathbb{R}$ maps the workspace properties and the robot dynamics in the following way:
	\begin{equation}
		\begin{aligned}
			\chi(w_j,q_j^0)=\text{dist}(q^0_j,w_j)+K\text{Area}(w_j)+\text{Turns}(w_j).
		\end{aligned}
	\end{equation}
\end{definition}


\subsection{Initialization and Return Distance}

A team of $n$ robots have $n$ starting locations. Depending on the partitioning scheme used, the starting location of a robot might be some distance away from its assigned partition. Since this travel distance may end up being significant, it needs to be accounted for in the metric. For example, assume $n$ robots have equal battery charge and same dynamics. In the scenario where robot $i$ is further to its assigned cell then robot $j$, we should expect robot $i$ to be responsible for smaller cell than robot $j$. We also assume that after the completion of robot's coverage task, it is required to come back to its original starting location.

This quantity that measures the distance of the robot's $j$ starting location to the assigned region, $w_j$, and back is:
\begin{equation}
	\text{dist}(q^0_j,w_j).
\end{equation}

There are several way to measure this quantity. For this paper, we utilize twice the shortest distance from the starting location to one of the points on the boundary of $w_j$. More formally, 
\begin{equation}
	\text{dist}(q^0_j,w_j)=2c_1\min_{x\in\partial w_j}||q^0_j-x||_2.
\end{equation}
where $c_1$ is the metric used in the cost function in Section~\ref{section:single_problem_statement}.

It is important to note that a straight path from the starting location to the closest point on the boundary of $w_j$ may not be always feasible as it may intersect an obstacle. However, it is clearly a lower bound on the cost of the actual path to get to the assigned region $w_j$ because of the triangular inequality. Hence,
\begin{equation}
	\text{dist}(q^0_j,w_j)\leq\ell(p_i).
\end{equation}
where $p_i$ is a feasible path from $q^0_j$ to the region $w_j$.


\subsection{Area of the Region}

Once the robot reaches the assigned workspace, it has to complete the coverage task. The amount of work required depends on the dynamics of the robot and the size and complexity of the workspace. Recall that the main method of coverage is via a Boustrophedon type path or a set of Boustrophedon type paths. Recall the structure of a Boustrophedon path. Mainly, such a path consists of a series of parallel straight line segments connected together via transition segments. In Section~\ref{section:single_problem_statement}, we have shown an interesting result that states that the total length of all parallel line segments combined is approximately proportional to the area of the workspace. In other words, we can use the area of a workspace to estimate a portion of the cost of the path. That is the portion that is associated with straight line segments. Here, we would like to show that with some modifications to the area we can get a lower bound estimate of such a value.

\simpleplot{img/chapter_4/riemann_sum}{Parallel line arrangment.}{fig:ch4_riemann_sum}

Suppose the workspace $w_i$ is filled with non-overlapping parallel straight line segments as shown in Figure~\ref{fig:ch4_riemann_sum}. Assuming that the footprint is a line of width $r$, the area covered by a robot traversing a line $l_1$ is:
\begin{equation}
	rl_i+k
\end{equation}
where $k$ is the amount of area covered beyond the starting and stop points of a line associated with footprint such as a circle. The total area covered in this way is then:
\begin{equation}
	\sum_{i=1}^n(rl_i+k)=A_{\text{covered}}\leq A_{\text{actual}}
\end{equation}

We would like to study the discrepancy between the area covered and the actual area of the workspace. To illustrate the reason why the covered area is less than the actual area refer to Figure~\ref{fig:line_footprint}. Assume that the coverage footprint is a circle.

\simpleplot{img/chapter_4/area_discrepancy}{Coverage footprint over a line.}{fig:line_footprint}

We shall now derive an expression for the discrepancy. Suppose a trapezoid is to be covered as shown in Figure~\ref{fig:error_derivation}. We would like to have an expression for the two corners of the trapezoid. First, the are of whole trapezoid is:


\simpleplot{img/chapter_4/area_error}{test}{fig:error_derivation}%
\simpleplot{img/chapter_4/area_error_i}{test}{fig:error_derivation_i}


However, here $r$ is held constant. Hence, we can compute the total length of these straight non-overlapping line segments by:
\begin{equation}
	\text{cost}=\sum_{i}l_i\approx\frac{\text{Area}(w_j)}{r}
\end{equation}

This quantity is clearly an under-estimator for the true length of the coverage path since transition lengths are not accounted for.


\subsection{Number of Turns}

The amount of work required for coverage depends on the area of the workspace and its complexity. We have accounted for the area of the workspace in the previous section. In this section, we will find a relation between polygons of equal area but varying complexity as shown in Figure~\ref{fig:area_complexity}.

\begin{figure}
	\centering
	\begin{subfigure}{0.5\linewidth}
		\centering
		\subfile{img/chapter_4/area_complexity}%
		\caption{\label{fig:area_complexity_i}}
	\end{subfigure}%
	\begin{subfigure}{0.5\linewidth}
		\centering
		\subfile{img/chapter_4/area_complexity_b}
		\caption{\label{fig:area_complexity_ii}}
	\end{subfigure}
	\caption{An example of polygons with same area but various complexity.}
	\label{fig:area_complexity}
\end{figure}

The difference between the two polygons in Figure~\ref{fig:area_complexity} is the complexity. Even though they have equal areas, they have different structure.

\todo{Should be noted in single agent}
For convex polygons, it is easy to establish the number of lines required for complete coverage. By the Riemann sum principle, a more complex polygon will have similar total length of straight line segments. However, they will have more segments in the first place. Each pair of segments needs to be connected. This connection has some length. Hence, one should expect the total overhead in terms of length of transition segments to go up as the number of straight segment goes up. Hence, if we scale the number of turns required for complete coverage by some distance, we compare the complexity of the polygon. However, to compute the true number of turns, one needs to compute a coverage path, which is hard. Hence, we rely on a lower bound or an under-estimator.

%This quantity is computed by computing the contours of the polygon. These contours are related to the notion of straight skeletons and medial axis[CITE]. An example of the type of algorithm for computing these contours is shown in Algorithm~\ref{alg:compute_contours}.

%Suppose we run Algorithm~\ref{alg:compute_contours} and we get a set of contours, $\mathcal{E}$.
%\begin{property}[Lower Bound on Turns]
%The lower bound on the number of turns for coverage of polygon $W$ is $|\mathcal{E}|$.
%\end{property}
%To prove this property, we begin by establishing this result in convex polygons.

\begin{proposition}
	Given a polygonal convex workspace $W$, $|\mathcal{E}|$ is a lower number of straight line segments required to cover $W$ compared to the Boustrophedon path.
\end{proposition}
\begin{proof}

Start with a convex shape. The distance to the skeleton is $\beta$. The minimum altitude is $\alpha$. By definition of the skeleton and the altitude, $\beta\leq 0.5\alpha$. But $|\mathcal{E}|=\ceil{\frac{\beta}{r}}$. Hence, any efficient coverage technique such as Boustrophedon coverage would need twice as many line for coverage, which support the claim of a lower bound.

Similar argument can be made for nonconvex shapes. The $|\mathcal{E}|$ should be at least $\ceil{\frac{\beta}{r}}$ and the following is still true $\beta\leq 0.5\alpha$. Therefore, the property is true.
\end{proof}

\begin{algorithm}
	\small
	\caption{$\operatorname{recalc\_encirclements}$}
	\label{alg:update_contours}
	\begin{algorithmic}[1]
		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$, Set of contours $\mathbb{E}$, cut $c$
		\STATE $\mathcal{C}\gets\emptyset$ 
		\REPEAT
			\STATE $E\gets$ \textit{parallel\_offset\_inwards}$(P)$
			\STATE $\mathcal{C}\gets\{\mathcal{C},E\}$
		\UNTIL{Shrinking results in a point or line}
		\RETURN $\mathcal{C}$
	\end{algorithmic}
\end{algorithm}


\section{Computational Complexity}

\section{Simulations}



\end{document}