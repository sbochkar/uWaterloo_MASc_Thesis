%!TEX root = ../main.tex

\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Multi-agent Coverage}
\label{chapter:multi_agent_coverage}

In this chapter, the multi-agent coverage problem is introduced. The problem statement is formalized in Section~\ref{section:multi_agent_problem_statement}. One of the important aspects of the algorithm is a decomposition metric used during the search algorithm. The design and analysis of this metric is in Section~\ref{section:multi_decomposition_metric}. The algorithm is proposed in Section~\ref{section:multi_algorithm}. Section~\ref{section:multi_comp_analysis} presents the computational complexity analysis of the algorithm. Lastly, Section~\ref{section:multi_simulations} presents simulations and a discussion of the results.


\section{Problem Statement}
\label{section:multi_agent_problem_statement}

A multi-agent coverage task is defined over a workspace $W$ and a team of $N$ robots. The workspace $W$ represents the area to be covered. The robots on the team are tasked with coverage. Each robot on a team has the same dynamics and hence, the same free configuration space $Q_{i,\text{free}}$. Each robot also has a coverage map $\mathcal{M}_i(q)$, which maps a configuration $q$ of robot $i$ to a set of points directly under the robot's coverage footprint. The objective of the problem is to compute a path for each robot such that the entire coverable space $\mathbb{C}$ is covered and the maximum path cost amongst all robot is minimized. This objective is motivated by the following.

Complicated tasks can be solved in a distributed manner with a team of robots. This is where the overall task is divided into $N$ subtasks and assigned to $N$ robots in the team. With this setup, it is often undesirable when one robot finishes its assigned subtask much later than other robots. This leads to excessive idle times for the rest of the team and unnecessarily long execution time for the overall task. This issue can be addressed if the subtask with the longest execution time is redistributed amongst other members of the team such that the duration of the overall task is reduced. In other words, amongst a collection of $N$ subtasks, one would like to modify subtasks such that the longest duration is minimized. As an example, such cost organization was used in~\cite{carlsson2009solving} for multi-depot vehicle routing problem.

Formally, this problem is introduced in Problem~\ref{problem:multi_cpp}.
\begin{problem}[Multi-agent Coverage Path Planning]
\label{problem:multi_cpp}
	Given a workspace $W$ and a team of $N$ homogeneous robots with the same coverage map, compute $\{p_1,p_2,\ldots,p_n\}$ with the following conditions:
	\begin{equation}
	\begin{aligned}
		& p_i\in P_{i},\ i=1,\dots,N,\\
		& \bigcup_{i=1,\dots,N}\left(\bigcup_{q\in p_i}\mathcal{M}_i(q)\right)=\mathbb{C},\\
		& \max_{i=1,\ldots,N}\{\mathcal{E}_i(p_i)\}\text{ is minimized.}
	\end{aligned}
	\end{equation}
\end{problem}

\begin{remark}[Heterogeneous Team]
	Notice that Problem~\ref{problem:multi_cpp} is defined for a team of homogeneous robots.
	A heterogeneous team consists of robots with different dynamics, which leads to coverage spaces that vary from robot to robot. Recall that coverage space determined by the configuration space of robot $u$ is defined in the following way:
	\begin{equation}
		\mathcal{C}_i=\bigcup_{q\in Q_{i,\text{free}}}\mathcal{M}_i(q).
	\end{equation}
	If $\mathcal{C}_i\neq\mathcal{C}_j$ then there exists some areas in the workspace that are coverable by only one of the robots. From the coverage planner's perspective, these areas need to be identified since their coverability is conditional on the dynamics of robots. This problem is beyond the scope of this thesis; hence, the team is assumed to consist of homogeneous robots only.

	\RE
\end{remark}

\begin{remark}[Path Costs]
	The path cost $\mathcal{E}(p_i)$ is the same cost described in Section~\ref{section:single_problem_statement}:
	\begin{equation}
		\mathcal{E}(p_i)=c_1\ell(p_i)+c_2a(p_i).
	\end{equation}
	Notably, this cost consists of two components: linear and angular. Similar assumption about the dynamics of the robots is made where $c_2\gg c_1$.

\RE
\end{remark}

Similar to steps taken in Chapter~\ref{section:single_problem_statement}, the Problem~\ref{problem:multi_cpp} is modified by reducing the search space for paths to a set of segmented feasible paths. The problem statement for this problem is shown in Problem~\ref{problem:multi_cpp_with_lines}.
\begin{problem}[Multi-agent Coverage Path Planning with Straight Line Segments]
\label{problem:multi_cpp_with_lines}
	Given a workspace $W$ and a team of $N$ homogeneous robots with the same coverage map, compute $\{p_1,p_2,\ldots,p_n\}$ with the following conditions:
	\begin{equation}
	\begin{aligned}
		& p_i\in P_{i,\text{segmented}},\ i=1,\dots,n,\\
		& \bigcup_{i=1,\dots,N}\left(\bigcup_{q\in p_i}\mathcal{M}_i(q)\right)=\mathbb{C},\\
		%& \sum_{i=1.\dots,n}\mathcal{E}_i(p_i)\text{ is minimized}.
		& \max_{i=1,\ldots,N}\{\mathcal{E}_i(p_i)\}\text{ is minimized.}
	\end{aligned}
	\end{equation}
\end{problem}

Finally, we transform Problem~\ref{problem:multi_cpp_with_lines} into an equivalent decoupled, two step problem. First, observe that a robot $i$ traversing a path $p_i$ covers a region $w_i$ where
\begin{equation}
	w_i=\bigcup_{q\in p_i}\mathcal{M}(q).
\end{equation}
By conditions stated in Problem~\ref{problem:multi_cpp_with_lines}, a team of robots has to entirely cover the coverable space. As a result, a solution to the problem has to satisfy the following:
\begin{equation}
	\label{eq:partition_condition}
	\bigcup_{i=1,\ldots,n}w_i=\mathbb{C}
\end{equation}

Notice that equation~(\ref{eq:partition_condition}) suggests some sort of decomposition of $\mathbb{C}$.
This observation motivates our decoupled approach to this problem. The first subproblem computes a $n$-cell decomposition for each agent followed by a single-agent path planning for each cell individually. The evaluation of the decomposition is performed with a metric designed to approximate the coverage path cost. This first subproblem is stated in Problem~\ref{problem:workspace_allocation}.

\begin{problem}[Workspace Allocation]
\label{problem:workspace_allocation}
	Given a workspace $W$ and $N$ robots with same dynamics, compute a decomposition of $\mathbb{C}$ into $\{w_1,w_2,\dots,w_N\}$ such that
	\begin{equation}
	\begin{aligned}
		& \bigcup_{i=1,\dots,N}w_i=\mathbb{C},\\
		& \max_{i=1,\ldots,N}\{\chi_i(w_i,q^0_i)\}\text{ is minimized.}
		%& \sum_{i=1,\dots,n}\chi(w_i,q_i)\text{ is minimized}.
	\end{aligned}
	\end{equation}
\end{problem}

We note that the second subproblem is the problem solved in Chapter~\ref{chapter:single_agent_coverage} and will not be covered in this section. The rest of this chapter focuses on the decomposition problem.

%\begin{equation}
%	\mathcal{C}_1=\mathcal{C}_2=\ldots=\mathcal{C}_n=\mathbb{C}.
%\end{equation}

%The general problem is now introduced in Problem~\ref{problem:multi_cpp}.

%Amongst $n$ robots in the team, these sets, $\mathcal{C}_1, \mathcal{C}_2,\ldots,\mathcal{C}_n$, may not necessarily be the same. Because of this, there are some regions in the workspace that may be accessible only by certain robots. This complicates the path planning process as the ability of a robot to cover a certain section of the workspace is conditional on the robot's dynamics. In this work, we make a simplifying assumption that if a point on the workspace is coverable by robot $i$, it is coverable by all other robots on the team. In other words, we assume that all robots have the same coverable space. That is:\todo[inline]{If we are going straight to this assumption, then the problem should just be defined for homogeneous robots.  You can use a remark to discuss the case of heterogeneity.}

%Notice that equation~(\ref{eq:partition_condition}) suggests some sort of decomposition of $\mathbb{C}$. This observation was used as a motivation behind our proposed approach. Hence, given that a few requirements are satisfied, it is possible to arrive to a solution of Problem~\ref{problem:multi_cpp_with_lines} if $w_i,i=1,\ldots,n$ are computed first followed by the computation of paths for each individual cell. The requirement for this to be true is that the computation of the decomposition has to take into account the capabilities of the robots. With our approach, we accomplish this by designing a metric $\chi$ in Section~\ref{section:multi_decomposition_metric}, which assigns an approximation cost of a path for a given polygon. Our approach consists of two decoupled subproblems: a decomposition problem and a single agent path planning problem. The first subproblem is stated in Problem~\ref{problem:workspace_allocation}.

%Suppose a decomposition of $\mathbb{C}$ is given with a guarantee that $\max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}$ would be minimized provided that all $p_i$ have the lowest possible cost. The decomposition is a set of cells $\{w_i\}$ where $\cup_{i=1}^nw_i=\mathbb{C}$. Provided with this set, one has to compute a lowest cost path $p_i$ for each $w_i$ in the decomposition for a solution to Problem~\ref{problem:multi_cpp_with_lines}.

% As such, the following problem and Problem~\ref{problem:multi_cpp_with_lines} are equivalent.
%\begin{problem}[]
%\label{problem:multi_cpp_with_lines_ii}
%	Given a workspace $W$, $n$ robots with dynamics and corresponding coverage map $\mathcal{M}_i$, compute
%	\begin{equation}
%	\begin{aligned}
%		&\{w_1,w_2,\ldots,w_n\},\\
%		&\{p_1,p_2,\ldots,p_n\}
%	\end{aligned}
%	\end{equation}
%	such that
%	\begin{equation}
%	\begin{aligned}
%		&i)& \bigcup_{i=1,\dots,n}(w_i)=\mathbb{C},\\
%		&iii) &\{p_i\in P_{\text{segmented},i}\ |\ i=1,\dots,n\},\\
%		&ii)&p_i\in w_i,\\
%		&ii)& \max_{i=1,\ldots,n}\{\mathcal{E}_i(p_i)\}\text{ is minimized,}\\
%		%& \sum_{i=1.\dots,n}\mathcal{E}_i(p_i)\text{ is minimized}.
%		&iv)&\mathcal{E}_i(p_i)\leq\mathcal{E}_i(p_j), \forall p_j\in P_{\text{segmented},i}\\
%	\end{aligned}
%	\end{equation}
%\end{problem}
%However, Problem~\ref{problem:multi_cpp_with_lines_ii} can be solved via a decoupled approach by solving two separate problems. The first problem deals with an optimal decomposition of the workspace. The second problem deals with computing the lowest cost paths for each cell in the decomposition. The first problem is shown in Problem~\ref{problem:workspace_allocation} while the second problem is just an invocation of Problem~\ref{problem:min_cost_cpp_with_lines} $n$ times. The solution to that problem is covered in Chapter~\ref{chapter:single_agent_coverage}.


\section{Decomposition Metric}
\label{section:multi_decomposition_metric}

The solution to Problem~\ref{problem:multi_cpp_with_lines} is a set of cells forming a decomposition of the coverable space. The evaluation of decomposition is performed with the metric $\chi$ that assigns coverage costs to polygons. Ideally, this metric would be the real cost of a coverage path for a given cell. However, as we have shown in Chapter~\ref{chapter:single_agent_coverage}, such metric would be computationally expensive. In this chapter, we develop an approximation of such cost that is easy to compute. This metric is shown in Definition~\ref{definition:decomp_metric}. The rest of the section discusses the design of this metric. 

\begin{definition}[Decomposition Metric]
\label{definition:decomp_metric}
Given a polygonal workspace $W$ and a robot with dynamics, the partition metric $\chi:W,Q\to\mathbb{R}$ maps the workspace and the robot dynamics to an approximation of a coverage path cost in the following way:
	\begin{equation}
		\chi(w_j,q_j^0)=c_1[\mathcal{F}_1(q^0_j,w_j)+\mathcal{F}_2(w_j)]+c_2\mathcal{F}_3(w_j).
	\end{equation}
Here, $w_j$ refers to a workspace assigned to robot $j$ and $q^0_j$ refers to the initial position of robot $j$, $\mathcal{F}_1, \mathcal{F}_2,\text{ and }\mathcal{F}_3$ refers to individual terms in the metric.
\end{definition}

\begin{remark}[Segmented Coverage Path Structure]
The design of the metric $\chi$ is motivated by the structure of a coverage path. A coverage path $p_i$ for a robot $i$ consists of three parts. The first part is the segment of the path from the starting location of the robot to its assigned region. The second part consisting of all the straight line segments used in the segmented coverage path. The last part includes all the transition segments connecting the straight segments together as shown in Figure~\ref{fig:path_parts}. Notice that the first two parts could be used as approximations for the linear component cost of the coverage path while the thirst part could be approximating the angular component. The following subsections discuss all three components in detail. \RE
\end{remark}

\begin{figure}
	\centering
	\subfile{img/chapter_5/path_parts}
	\caption{The structure of a coverage path. Orange: Segments where the robot travels to its assigned region shown in blue. Red: Path segments that are straight line segments. Yellow: path segments that are transition segments.}
	\label{fig:path_parts}
\end{figure}


\subsection{Initialization and Return Distance}
\label{subsection:init_ret_distance}

This term is designed to approximate the travel distance of a robot from its starting location to its assigned task. To demonstrate the important of this term, consider the following. A team of $N$ robots have $N$ starting locations, $q^0_1,q^0_2,\ldots,q^0_N$. Depending on the decomposition technique, the starting location of a robot may be some distance away from its assigned cell. Since this travel distance may be significant, it cannot be ignored when computing the cost of a path. For example, assume $N$ robots have equal battery charge and same dynamics. In the scenario where robot $i$ is further to its assigned cell then robot $j$, robot $i$ should be responsible for smaller cell than robot $j$. We also assume that after the completion of robot's coverage task, it is required to come back to its original starting location.

This first term of the metric $\chi$ is the following: 
\begin{equation}
	\mathcal{F}_1(q^0_i,w_i)=2\min_{x\in\partial w_i}||q^0_i-x||_2.
\end{equation}

\begin{proposition}
	$\mathcal{F}_1$ is a lower bound for the actual distance from the robot's initial position to the start of the coverage path.
\end{proposition}
\begin{proof}
	Denote the combined distance from the starting location of the robot $i$, $q^0_i$, to the start of the coverage path in $w_i$, and the distance from the end of the path to $q^0_i$ be denoted as
	\begin{equation}
		\text{dist}(q^0_i,w_i).
	\end{equation}

	Since a path $p_i$ is defined in a metric space, triangular inequality hold. Hence, the following is true:
	\begin{equation}
		\mathcal{F}_1(q^0_i,w_i)\leq2\text{dist}(q^0_i,w_i).
	\end{equation}
\end{proof}

\begin{remark}[Infeasible Paths]
The benefit of this approximation is its simplicity and ease of computation. However, it is important to note that a straight path from the starting location to the closest point on the boundary of $w_i$ may not always be feasible as it may intersect an obstacle. Therefore, a situation is possible where the distance from the starting location to the assigned region is close but in reality, requires extensive navigation through obstacles. A way to mitigate this situation is by computing the distance of a shortest feasible path to $w_i$. However, this requires utilization of visibility graphs, which is computationally expensive~\cite{planning-kinematics}.
\end{remark}


\subsection{Length of Straight Line Segments}
\label{subsection:sum_straight_segments}

Once the robot reaches the start of its coverage path, the coverage process begins. The second term of the metric $\chi$ is designed to approximate the length of all the straight length segments of the coverage path. This approximation is computed using the area of the assigned polygon with a few modifications.

The second term of the metric $\chi$ is the following:
\begin{equation}
	\mathcal{F}_2(w_i)=\frac{A_{\text{actual}}(w_i)-A_{\text{uncovered}}^{\max}(w_i)}{r}.
\end{equation}
In this term, $A_{\text{actual}}(w_i)$ refers to the area of the polygon $w_i$ and $A_{\text{uncovered}}^{\max}(w_i)$ refers to an estimate of all the uncovered area in the polygon.

Suppose a workspace $w_i$ is filled with non-overlapping parallel straight line segments as shown in Figure~\ref{fig:line_footprint}. Assuming that the coverage footprint has a width of $r$, then the area covered by a robot traversing a line of length $l_i$ is $rl_i+k$. Here, $k$ is the amount of area covered beyond the starting and stopping points of a line. These areas are associated with footprints such as a circle as demonstrated by half circles in Figure~\ref{fig:line_footprint}. The total area covered in this way is equal to
\begin{equation}
	\label{eq:covered_area}
	A_{\text{covered}} = \sum_{i=1}^n(rl_i+k).
\end{equation}

\begin{figure}
	\centering
	\subfile{img/chapter_5/area_discrepancy}
	\caption{Coverage footprints over lines.}
	\label{fig:line_footprint}
\end{figure}

Note that $A_{\text{covered}}$ is not known prior to computing the coverage path. But it can be computed from the following relation: 
\begin{equation}
	A_{\text{covered}}=A_{\text{actual}}-A_{\text{uncovered}}.
\end{equation}
The term $A_{\text{uncovered}}$ represents the area near the borders of the workspace that remain uncovered as shown in Figure~\ref{fig:line_footprint}. 

The expression for term $A_{\text{uncovered}}$ is derived in Appendix~\ref{appendix:area_term_derivation} and have the following form:
\begin{equation}
	A_{\text{uncovered}}=\frac{r^2}{2}(4\csc\theta-\pi).
\end{equation}
However, this term is a function of $\theta$, which is not known prior to computing the actual coverage path. As such, an upper bound is derived in Appendix~\ref{appendix:area_term_derivation}:
\begin{equation}
	A_{\text{uncovered}}^{\max}=\ceil{\frac{\alpha_{\min}}{r}}r^2(4\csc\theta_{\max}-\pi).
\end{equation}

With an easily computable expression for $A_{\text{uncovered}}^{\max}$, the expression for the total length of straight line segments can be stated as follows:
\begin{equation}
	\mathcal{F}_2(w_i)=\frac{A_{\text{actual}}-A_{\text{uncovered}}^{\max}}{r}.
\end{equation}

\begin{proposition}[Lower Bound of Total Length of Straight Line Segments]
The term $\mathcal{F}_2(w_i)$ is a lower bound to the actual total length of straight line segments in a segmented path.
\end{proposition}
\begin{proof}
The term $A_{\text{uncovered}}^{\max}$ was computed with the value of $\theta_{\max}$ that maximizes the $A_{\text{uncovered}}$ function. Moreover, the cardinality of set $S$ is approximated by $\ceil{\frac{\alpha_{\min}}{r}}$ where $|S|\leq\ceil{\frac{\alpha_{\min}}{r}}$. Hence, the following is true:
\begin{equation}
\begin{aligned}
	&A_{\text{uncovered}}^{\max}\geq A_{\text{uncovered}},\\
	\Longrightarrow\  &\mathcal{F}_2(w_i)\leq\sum_{i=1}^Nl_i.
	\end{aligned}
\end{equation}
\end{proof}

%Recall from Chapter~\ref{chapter:single_agent_coverage} that the coverage is achieved through the type of paths called segmented paths. In Section~\ref{section:single_problem_statement}, a relation between the area of the workspace and the total length of all straight line segments is demonstrated:
%\begin{equation}
%	\sum_i \ell_i\approx\frac{A-nk}{r}.
%\end{equation}
%The area of a workspace can be used to estimate a linear component of the path cost. In this section, we show that with some modifications to the area, a lower bound estimate for the length of straight line segments can be computed cheaply.


\subsection{Angular Component}
\label{subsection:angular_component}

The last term is designed to approximate the angular component of the coverage path. As discussed in Chapter~\ref{chapter:single_agent_coverage}, coverage is achieved through segmented paths. With such paths, only transition segments contribute to the angular component of the cost. One can calculate the angular component of the path by computing the path and counting the transition segments. However, this  is computationally intensive. In this section, we develop an approximation for the angular component of the coverage path that makes use of a set of contours. This last term of the metric $\chi$ is the following:
\begin{equation}
	\label{eq:f3}
	\mathcal{F}_3(w_i)=360^o|\mathcal{T}|
\end{equation}%
where $\mathcal{T}$ is a set of contours.

Contours were used for coverage path planning before for computing a contour-parallel paths~\cite{held1991computational}. A contour is a closed chain generated by \emph{shrinking} the polygon's boundary inwards by a fixed distance. If this process is performed repeatedly where each resultant contour is shrunk by distance $2r$ every iteration, eventually these contours will converge to a point or a line called the center contour as shown in Figure~\ref{fig:skeleton_altitude}. Let us denote the set of these closed contours, spaced distance $2r$ apart where $r$ is the radius of the coverage footprint, as $\mathcal{T}$. An example of such a set is shown in Figure~\ref{fig:skeleton_altitude}.

The computation of these contours requires no knowledge of the actual coverage path as is solely determined by the shape of the polygon. Furthermore, the angular component of each contour is at least $360^o$. This fact and the following proposition leads to the form of $\mathcal{F}_3$ shown in equation~\ref{eq:f3}.

\begin{proposition}
	Given a polygonal convex workspace $W$, suppose a set of contours, $\mathcal{T}$ is computed. Let the coverage angle of a Boustrophedon path be $\Phi$. The the following holds:
	\begin{equation}
		360^o|\mathcal{T}|\leq\Phi.
	\end{equation}
\end{proposition}

\begin{proof}
The result is shown for convex polygons first. The process of iteratively shrinking the boundary converges to the center contour as shown in thick line in Figure~\ref{fig:skeleton_altitude}. The distance from any edge of the convex polygon to the center contour is $\beta$. Suppose that the minimum altitude of the same convex polygon is $\alpha$. By construction of the center contour and the minimum altitude, the following holds:
\begin{equation}
	\beta\leq\frac{\alpha}{2}.
\end{equation}

\begin{figure}
	\centering
	\subfile{img/chapter_5/skeleton_altitude}
	\caption{Minimum altitude of a convex polygon, $\alpha$. Distance to the center contour, $\beta$.}
	\label{fig:skeleton_altitude}
\end{figure}

However, recall that $\Phi=180^o\ceil{\frac{\alpha}{r}}$ and $|\mathcal{T}|=\ceil{\frac{\beta}{r}}$. Assuming that $\frac{\alpha}{r}$ is exact then
\begin{equation}
	360^o|\mathcal{T}|\leq180^o\frac{\alpha}{r}
\end{equation}

Recall that concave polygons can be decomposed into a set of convex cells. We have also demonstrated that a decomposition can be constructed that minimizes the sum of minimum altitudes over all convex cells in Chapter~\ref{chapter:single_agent_coverage}. The sum of all minimum altitudes is related to the number of parallel line segments required for coverage. Hence, a coverage angle can also be computed. Also note that every convex cell has its own center contour. However, it was shown that $360^o\frac{\beta}{r}\leq\Phi$ for convex polygons. Hence, the summation over all cells will hold as well.
\end{proof}

%\begin{figure}
%	\centering
%	\begin{subfigure}{0.5\linewidth}
%		\centering
%		\subfile{img/chapter_5/area_complexity}%
%		\caption{\label{fig:area_complexity_i}}
%	\end{subfigure}%
%	\begin{subfigure}{0.5\linewidth}
%		\centering
%		\subfile{img/chapter_5/area_complexity_b}
%		\caption{\label{fig:area_complexity_ii}}
%	\end{subfigure}
%	\caption{An example of polygons with same area but various complexity.}
%	\label{fig:area_complexity}
%\end{figure}


\section{Area Allocation Algorithm}
\label{section:multi_algorithm}

The algorithm proposed in this section is based on a greedy pair-wise optimization search from some starting point. The procedure is initialized with any $n$-cell decomposition. For certain adjacent pairs of cells in this decomposition, a search is performed for a new cut that would improve the pair-wise maximum cost. This process terminates when no pair-wise improvements to the decomposition can be made. %The pair-wise optimality is ensured via a linear search over a sampled search space. The whole process is started off with an initial solution.

The optimization strategy is shown in Algorithm~\ref{alg:optimization_procedure}. The goal of this algorithm is to identify a cell with the maximum cost and attempt a re-optimization step. As inputs, the algorithm accepts a polygon describing the coverable space and a set of starting positions for each robot in the team. The optimization procedure is initialized with some decomposition on Line~\ref{line:multi_init_decomp}. This decomposition could be any decomposition that partitions $\mathbb{C}$ into $n$ cells. On Line~\ref{line:multi_adjacency}, the adjacency graph is computed for the current decomposition. Costs are computed for all cells in the decomposition and the cell with the maximum cost is identified on Line~\ref{line:multi_cost}. On Line~\ref{line:multi_reopt_recursion}, a recursive procedure is called on the cell with the highest cost. This procedure returns, if possible, a modified decomposition where some two adjacent cells in the decomposition were re-optimized. This procedure terminated when the decomposition remains unchanged after the re-optimization step.

\begin{algorithm}
	\caption{$\text{optimization\_procedure}(\mathbb{C}, \{q^0_i\})$}
	\label{alg:optimization_procedure}
	\begin{algorithmic}[1]
		\REQUIRE Polygon $\mathbb{C}=\{Z_0,Z_1,\ldots\}$, Set of starting locations $\{q^0_i\}$
			\STATE $\mathcal{D}\gets$ some decomposition of $\mathbb{C}$ consisting of $n$ cells \label{line:multi_init_decomp}
			\REPEAT
			\STATE $\mathcal{G}\gets$ adjacency graph of $\mathcal{D}$ \label{line:multi_adjacency}
			\STATE $\chi^{\max}_i,v_i\gets$ the cost and index of highest cost vertex in $\mathcal{G}$ \label{line:multi_cost}
			\STATE $\mathcal{D}\gets\text{reopt\_recursion}(\mathcal{D},\mathcal{G}, v_i)$ \label{line:multi_reopt_recursion}
			\UNTIL{$\mathcal{D}$ stops changing}
	\end{algorithmic}
\end{algorithm}

The call on Line~\ref{line:multi_reopt_recursion} of Algorithm~\ref{alg:optimization_procedure} is a recursive procedure called on the cell with the highest cost in the current decomposition. This procedure is recursive to account for situations where the cost of the maximum cell cannot be improved via pair-wise re-optimizations with the cell's neighbors. This situations may arise when the costs of the neighbors are similar to the highest cell. As such, the procedure recursively attempts to re-optimize the neighbors through their children with the hope that in the next iteration, the highest cell can be improved. This procedure is described in Algorithm~\ref{alg:reopt_recursion}.

The Algorithm~\ref{alg:reopt_recursion} is a depth-first traversal of the adjacency graph. Cycles are avoided by restricting recursive calls to cells with lower costs. The procedure accepts a decomposition, an adjacency graph, and a vertex representing a cell in the decomposition as inputs. For each neighboring vertex to $v_i$ that has a lower cost, the procedure performs the following steps. On Line~\ref{line:multi_reopt_cut}, a re-optimization cut is attempted for $v_i$ and $v_j$. If the re-optimization cut was not successful, meaning it failed to find a cut that would decrease the pair-wise maximum, then the same procedure is called on $v_j$ on Line~\ref{line:multi_recursive_call}. If the re-optimization cut was successful then the current decomposition is modified with the new cut and the procedure terminates.

\begin{algorithm}
	\caption{$\text{reopt\_recursion}(\mathcal{D}, \mathcal{G}, v_i)$}
	\label{alg:reopt_recursion}
	\begin{algorithmic}[1]
		\REQUIRE Decomposition $\mathcal{D}=\{C_0,C_1,\ldots\}$, Adjacency graph $\mathcal{G}$, Vertex $v_i$
			\FOR{$v_j\in\mathcal{N}_{v_i}$}
				\IF{$\chi(v_j)<\chi(v_i)$}
					\STATE $\mathcal{D}_{\text{new}}\gets\text{reopt\_cut}(v_i,v_j,\mathcal{D},\mathcal{G})$ \label{line:multi_reopt_cut}
					\IF{$\mathcal{D}_{\text{new}}=\mathcal{D}$}
						\STATE $\mathcal{D}_{\text{new}}\gets$reopt\_recursion($\mathcal{D},v_j$)\label{line:multi_recursive_call}
					\ENDIF
					\RETURN $\mathcal{D}_{\text{new}}$
				\ENDIF
			\ENDFOR
	\end{algorithmic}
\end{algorithm}

It should be noted that a breadth-first traversal version of Algorithm~\ref{alg:reopt_recursion} is also available and is shown in Algorithm~\ref{alg:reopt_recursion_bft}. With this approach, the all immediate neighbors of the highest cell are attempted to be re-optimized first before continuing to the next level. It should be noted that in simulations, this approach converged to the same results as the depth-first traversal.

\begin{algorithm}
	\caption{$\text{reopt\_recursion\_bft}(\mathcal{D}, \mathcal{G}, v_i, Q)$}
	\label{alg:reopt_recursion_bft}
	\begin{algorithmic}[1]
		\REQUIRE Decomposition $\mathcal{D}=\{C_0,C_1,\ldots\}$, Adjacency graph $\mathcal{G}$, Vertex $v_i$, Queue $Q$
			\IF{$Q$ is empty}
				\RETURN $\mathcal{D}$
			\ENDIF
			\STATE $v_i\gets$ pop from $Q$
			\FOR{$v_j\in\mathcal{N}_{v_i}$}
				\IF{$\chi(v_j)<\chi(v_i)$}
					\STATE $\mathcal{D}_{\text{new}}\gets\text{reopt\_cut}(v_i,v_j,\mathcal{D},\mathcal{G})$ \label{line:multi_reopt_cut}
					\IF{$\mathcal{D}_{\text{new}}=\mathcal{D}$}
						\STATE Push $v_j$ to $Q$
					\ELSE
						\RETURN $\mathcal{D}_{\text{new}}$
					\ENDIF
				\ENDIF
			\ENDFOR
			\RETURN $\text{reopt\_recursion\_bft}(\mathcal{D}, \mathcal{G}, v_i, Q)$
	\end{algorithmic}
\end{algorithm}


Another important procedure is described in Algorithm~\ref{alg:reopt_cut}. It is a procedure for recomputing a cut that would minimize the maximum cost. In this procedure, the two adjacent cells are combined into one cell on Line~\ref{line:poly_union}. A cut space is generated from the origin of the cut on Line~\ref{line:multi_cut_space}. This cut space is sampled with equally spaced $K$ points on Line~\ref{line:sample_cut_space}. A cut is performed for each point in $\mathcal{L}$ and evaluated. The best cut is found on Line~\ref{line:search}. This cut could be the original cut if no improving cuts were found. The cut is then implemented and the current decomposition is modified.

\begin{algorithm}
	\caption{$\text{reopt\_cut}(v_i, v_j, \mathcal{D},\mathcal{G})$}
	\label{alg:reopt_cut}
	\begin{algorithmic}[1]
		\REQUIRE Vertices $v_i, v_j$, Decomposition $\mathcal{D}$, Adjacency graph $\mathcal{G}$
			\STATE $c\gets$ shared edge between $v_i$ and $v_j$ \label{line:shared_edge}
			\STATE $p_s,p_e\gets$ endpoints of $c$
			\STATE $w_{\text{temp}}\gets \mathcal{D}(v_i)\cup\mathcal{D}(v_j)$ \label{line:poly_union}
			\STATE $S\gets$ cut space in $w_{\text{temp}}$ generated from $p_s$ \label{line:multi_cut_space}
			\STATE $\mathcal{L}\gets$ sample $S$ with $K$ points \label{line:sample_cut_space}
			\STATE $p_e^{'}\gets$ point from $\mathcal{L}$ that minimizes the maximum $\{\chi(w_a),\chi(_b)\}$ \label{line:search}
			\STATE $c^{'}\gets$ cut ($p_s,p_e^{'}$)
			\STATE $w_a,w_b\gets$cut $w_{\text{temp}}$ with $c^{'}$ \label{line:perform_cut}
			\STATE $\mathcal{D}_{\text{new}}\gets\mathcal{D}$ modified with $w_a,w_b$
			\RETURN $\mathcal{D}_{\text{new}}$
	\end{algorithmic}
\end{algorithm}

Lastly, an algorithm for computing the metric $\chi$ is shown in Algorithm~\ref{alg:metric_algorithm}. Note that this procedure calculates the three terms as a function of the polygon and the starting location of the robot. The detailed description of the computation of these terms was described in Section~\ref{section:multi_decomposition_metric}.

\begin{algorithm}
	\caption{$\text{compute\_}\chi(q^0, w)$}
	\label{alg:metric_algorithm}
	\begin{algorithmic}[1]
		\REQUIRE Initial position $q^0$, Polygon $w=\{Z_0,Z_1,\ldots\}$ 
		\STATE $\mathcal{F}_1\gets2\min_{x\in\partial w}||q^0-x||_2$ \label{line:min_dist}
		\STATE $A_\text{actual}\gets$ area of $w$	\label{line:area}
		\STATE $\Theta\gets$ angles of all edges w.r.t. the $x$-axis.	\label{line:all_edge}
		\STATE $\theta_{\max}\gets$ largest difference between any two pairs of elements of $\Theta$ \label{line:all_pairs}
		\STATE $\alpha_{\min}\gets$ minimum altitude of $w$	\label{line:multi_alt}
		\STATE $A^{\max}_{\text{uncovered}}\gets\alpha_{\min}r(4\csc{\theta_{\max}}-\pi)$ \label{line:a_uncovered}
		\STATE $\mathcal{F}_2\gets\frac{A_\text{actual}-A^{\max}_{\text{uncovered}}}{r}$
		\STATE $\mathcal{T}\gets$ compute contours of $w$	\label{line:contours}
		\STATE $\mathcal{F}_3\gets360^o|\mathcal{T}|$
		\RETURN $c_1(\mathcal{F}_1+\mathcal{F}_2)+c_2\mathcal{F}_3$
	\end{algorithmic}
\end{algorithm}

An example of the algorithm in action is shown in Figure~\ref{fig:algo_demo}. The top picture depicts the initial decomposition of the rectangular workspace into three cells. The initial positions of the three robots are in the lower left corner of the workspace. The initial decomposition was designed such that the cells two and three has almost equal costs while cell one has the minimum cost. The algorithm identifies the cell three to be the cell with the highest cost. During the recursive call, the algorithm attempts to re-optimize the cut between cell three and two. However, due to costs being almost equal, no improving cuts were found. As a result, a recursive call is called on cell two. Here, cell two is re-optimized with cell one, resulting in lower cost of cell two shown in the middle picture. Finally, the bottom picture shows the next iteration of the algorithm where the cell three is re-optimized with the modified cell two, resulting in the decreased maximum cost. 

\begin{figure*}
		\centering
		\includegraphics[width=0.75\textwidth]{img/chapter_5/demo_1_a.pdf} 
		\includegraphics[width=0.75\textwidth]{img/chapter_5/demo_2_a.pdf}
		\includegraphics[width=0.75\textwidth]{img/chapter_5/demo_3_a.pdf} 	
		\begin{tikzpicture}[remember picture,overlay]
			\fill [fill=black] (-2.0,6.1) circle [radius=2pt];
			\fill [fill=black] (-2.0,3.5) circle [radius=2pt];
			\fill [fill=black] (-2.0,1.2) circle [radius=2pt];
			
			\node at (-1.8,6.1) {$3$};
			\node at (-1.8,3.5) {$3$};
			\node at (-1.8,1.2) {$3$};
			
			\fill [fill=black] (-5.0,6.1) circle [radius=2pt];
			\fill [fill=black] (-5.0,3.5) circle [radius=2pt];
			\fill [fill=black] (-5.0,1.2) circle [radius=2pt];
			
			\node at (-4.8,6.1) {$2$};
			\node at (-4.8,3.5) {$2$};
			\node at (-4.8,1.2) {$2$};			

			\fill [fill=black] (-11.0,6.1) circle [radius=2pt];
			\fill [fill=black] (-11.0,3.5) circle [radius=2pt];
			\fill [fill=black] (-11.0,1.2) circle [radius=2pt];
			
			\node at (-10.8,6.1) {$1$};
			\node at (-10.8,3.5) {$1$};
			\node at (-10.8,1.2) {$1$};			

			\fill [fill=gray] (-11.72,0.60) circle [radius=4pt];
			\fill [fill=gray] (-11.64,3.05) circle [radius=4pt];
			\fill [fill=gray] (-11.73,5.56) circle [radius=4pt];

		\end{tikzpicture}
	\caption{Top: initial decomposition. Middle: after first iteration. Bottom: after second iteration.}
	\label{fig:algo_demo}
\end{figure*}





%			\IF{$\chi(v_i)>\chi(v_j)$}
%				\STATE dir$\gets$ CW \COMMENT{w.l.g assume $v_i$ is to the left of $c$}
%			\ELSE
%				\STATE dir$\gets$ CCW
%			\ENDIF			
%			\FOR{each $p_i\in S$ in direction dir}
%				\STATE $w_a,w_b\gets$cut $w_{\text{temp}}$ with an edge $(p_s,p_i$)
%				\IF{dir is CW and $\chi(w_a)>\chi(w_b)$}
%					\STATE \COMMENT{Reverse inequality sign for CCW}
%					\STATE $V\gets$ sample edge($v_i,v_{i-1}$) with $K$ points
%					\STATE $v_b\gets$ point from $V$ that minimizes the maximum $\{\chi(w^{'}_a),\chi(w^{'}_b)\}$
%					\STATE $c^{'}\gets$ cut ($v_i,v_b$)
%					\STATE $w_a,w_b\gets$ cut $w_{\text{temp}}$ with $c^{'}$
%					\RETURN $w_a,w_b$
%					
%				\ENDIF
%			\ENDFOR


%\begin{algorithm}
%	\caption{$\text{optimization\_procedure}(\mathbb{C}, \{q^0_i\})$}
%	\label{alg:optimization_procedure}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $\mathbb{C}=\{Z_0,Z_1,\ldots\}$, Set of starting locations $\{q^0_i\}$
%			\STATE $D\gets$ anchored\_area\_partition$(\mathbb{C},\{q^0_i\},\frac{1}{n})$. \label{line:area_part}
%			\STATE $\mathcal{G}\gets$ adjacency graph of $D$.
%			\STATE $M\gets\chi(q^0_i,w_i), \forall w_i\in D$.
%			\REPEAT
%				\STATE $w_a\gets w_i$ from $D$ with highest $\chi(q^0_i,w_i)$.
%				\STATE $w_b\gets$ some $w_j\in D$ adjacent to $w_a$ with lowest $\chi(q^0_j,w_j)$.
%				%\STATE $w_{\text{temp}}\gets w_a\cup b_j$
%				\STATE $w_i,w_j\gets$ equitable\_cut($w_a,w_b$).
%				\STATE Modify $M$ with new costs.%\chi(q^0_j,w_j)$ and $\chi(q^0_i,w_i)$ accordingly
%				\STATE Modify $D$ with $w_i,w_j$.
%			\UNTIL{Maximum $\chi(q^0_j,w_j)\in M$ stops decreasing}
%			\RETURN $D$
%	\end{algorithmic}
%\end{algorithm}


%\begin{algorithm}
%	%\small
%	\caption{$\text{optimization\_procedure}(\mathbb{C}, \{q^0_i\})$}
%	\label{alg:optimization_procedure}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $\mathbb{C}=\{Z_0,Z_1,\ldots\}$, Set of starting locations $\{q^0_i\}$
%			%\STATE $V\gets n$ virtual starting locations placed randomly on the boundary of $P$ \label{line:1_start_locs}
%			\STATE $D\gets$ anchored\_area\_partition$(\mathbb{C},\{q^0_i\},\frac{1}{n})$ \label{line:area_part}
%			\STATE $\mathcal{G}\gets$ adjacency graph of $D$
%			\STATE $M\gets\chi(q^0_i,w_i), \forall w_i\in D$ 
%			%\STATE Add all cells in $D$ to the queue $Q$
%			\REPEAT
%				\STATE $w_a\gets w_i$ from $D$ with highest $\chi(q^0_i,w_i)$
%				\STATE $w_b\gets$ some $w_j\in D$ adjacent to $w_a$ with lowest $\chi(q^0_j,w_j)$
%				\STATE $w_{\text{temp}}\gets w_a\cup b_j$
%				\STATE $\Delta\chi\gets\frac{|\chi_2-\chi_1|}{\chi_2+\chi_1}$
%				\STATE $A_t\gets$ Half of area of $w_{\text{temp}}$
%				\STATE $w_i,w_j\gets$ anchored\_area\_partition($w_{\text{temp}},(q^0_i,q^0_j),(A_t+\Delta\chi,A_t-\Delta\chi)$\label{line:distr_opt_cut}
%				%\STATE $\mathbb{E}\gets$ \text{compute\_encirclements}$(p_{\operatorname{temp}})$ \label{line:compute_encirlment}
%				%\STATE $\sigma_{\ell}\gets$ compute\_encirclements($p_{\ell}$) \label{line:recalc_encirclemnts_1}
%				%\STATE $\sigma_r\gets$ compute\_encirclements($p_r$) \label{line:recalc_encirclemnts_2}
%				%\STATE $\sigma_{\ell}\gets$ recalc\_encirclements($p_{\ell},\mathbb{E}, c$) \label{line:recalc_encirclemnts_1}
%				%\STATE $\sigma_r\gets$ recalc\_encirclements($p_r, \mathbb{E}, c$) \label{line:recalc_encirclemnts_2}
%				%\STATE Cost $\gets\chi(s_i,p_{\ell},\sigma_{\ell})+\phi(s_j,p_r,\sigma_r$) 
%				%\STATE Cost $\gets\max\{\chi(s_i,p_{\ell}),\chi(s_j,p_r)\}$ 
%				%\STATE Implement $c$ that resulted in lowest cost, modify $D$.
%				\STATE Modify $\chi(q^0_j,w_j)$ and $\chi(q^0_i,w_i)$ accordingly
%				\STATE Modify $D$ with $w_i,w_j$
%			\UNTIL{Maximum $\chi(q^0_j,w_j)\forall w_j\in D$ stops decreasing}
%			\RETURN $D$
%	\end{algorithmic}
%\end{algorithm}

%Another important sub-procedure is the call to anchored area partition procedure. This procedure is based on the work by Hert~\cite{hert1998polygon} and his approach to area partitioning problem. The procedure is summarized in Algorithm~\ref{alg:anchored_area_partition}. This algorithm allows for making cuts without having to discretized the coverable area. Moreover, a series of cuts are made to form $n$ cells with area specified as an input to the algorithm. For brevity, we only show the algorithm for convex polygons here. The full algorithm will be available in the Appendix.

%\begin{algorithm}
%	\caption{$\text{anchored\_area\_partition}(w, (q^0_i,q^0_j), A_1,A_2)$}
%	\label{alg:anchored_area_partition}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $w=\{Z_0,Z_1,\ldots\}$, Tuple of starting locations $(q_i,q_j)$, tuple of required areas
%		\STATE $V(w)\gets$ list of vertices in CCW order
%		\STATE Order $q^0_i,q^0_j$ according to this order as well
%		\STATE Initialize the cut $L=(L_s,L_e)$ as an edge $(v_0,q^0_1)$
%		\WHILE{$\text{Area}(w_j)<A_2$ or $L_e!=q^0_2$}
%			\STATE Move $L_e$ CCW
%		\ENDWHILE
%		\IF{$\text{Area}(w_j)<A_2$}
%			\WHILE{$\text{Area}(w_j)<A_2$}
%				\STATE Move $L_s$ CW
%			\ENDWHILE
%		\ENDIF
%		\RETURN $w_i,w_j$
%	\end{algorithmic}
%\end{algorithm}

%In Algorithm~\ref{alg:optimization_procedure}, in Line~\ref{line:compute_encirlment}, a procedure is called to compute \emph{encirclements}. The procedure for computing them is shown in Algorithm~\ref{alg:compute_contours}.
%\begin{algorithm}
%	\small
%	\caption{$\operatorname{compute\_encirclements}$}
%	\label{alg:compute_contours}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$
%		\STATE $\mathcal{C}\gets\emptyset$ 
%		\REPEAT
%			\STATE $C\gets$ \textit{parallel\_offset\_inwards}$(P)$
%			\STATE $\mathcal{C}\gets C$
%		\UNTIL{No further shrinking possible}
%		\RETURN $\mathcal{C}$
%	\end{algorithmic}
%\end{algorithm}
%
%The Algorithm~\ref{alg:update_contours} shows a procedure for recalculating the number of encirclements to avoid constant re-computation of contours. This increases the efficiency of the algorithm.
%\begin{algorithm}
%	\small
%	\caption{$\operatorname{recalc\_encirclements}$}
%	\label{alg:update_contours}
%	\begin{algorithmic}[1]
%		\REQUIRE Polygon $P=\{Z_0,Z_1,\ldots\}$, Set of contours $\mathbb{E}$, cut $c$
%		\STATE $\mathcal{C}\gets\emptyset$ 
%		\REPEAT
%			\STATE $C\gets$ \textit{parallel\_offset\_inwards}$(P)$
%			\STATE $\mathcal{C}\gets C$
%		\UNTIL{Shrinking results in a point or line}
%		\RETURN $\mathcal{C}$
%	\end{algorithmic}
%\end{algorithm}


\section{Computational Complexity}
\label{section:multi_comp_analysis}

The run time of Algorithm~\ref{alg:metric_algorithm} is determined as follows. Line~\ref{line:min_dist} computes the minimum distance from a fixed points to a set of points. This operation is performed through an exhaustive search in $\mathbb{O}(n)$ time by iterating over all vertices in the set. On Line~\ref{line:area}, the area of a polygon is computed in $\mathbb{O}(n)$ time by using Gauss's area formula. On Line~\ref{line:all_edge}, a set of angles is computed in $\mathbb{O}(n)$ time by traversing over all edges of the polygon. On Line~\ref{line:all_pairs}, the largest pair-wise difference between any two pairs of elements is computed in $\mathbb{O}(n^2)$ time by evaluating all possible pairings. The minimum altitude is computed using Algorithm~\ref{alg:altitude} in $\mathbb{O}(n^2\log{n})$ time. A set of contours is computed on Line~\ref{line:contours}. In our implementation of this step, a Shapely library is used. The run time of this implementation is not known. However, a robust implementation of contour computation was proposed by Chen~\cite{chen2005polygon}. The algorithm computes one contour in $\mathbb{O}((n+k)\log{n})$ time where $n$ is he number of edges and $k$ can be roughly approximated by the number of convex vertices in the polygon. Hence, $n+k=2n$ for convex polygons. Furthermore, to compute the set of contours $\mathcal{T}$, this operation needs to be called several times. This number of times is determined by the shape of the polygon. However, a upper bound on this number can be computed using the minimum altitude of a polygon, $\frac{\alpha_{\min}}{r}$. As such, the overall complexity of Algorithm~\ref{alg:metric_algorithm} is $\mathbb{O}(n^2\log{n}+\frac{\alpha_{\min}}{r}n\log{n})$.

Algorithm~\ref{alg:reopt_cut} computes an improving cut if it exists. Starting with Line~\ref{line:shared_edge}, an edge is found that is common to both adjacent cells. One way of computing such edge is by checking equality for each pair of edges from both polygons. This operation is $\mathbb{O}(mn)$ time where $m$ and $n$ is the number of verticies in left and right polygons respectively. On Line~\ref{line:poly_union}, a union of the two polygons is computed. This operation can be performed by combining the two boundary chains together at the common edge. Since the indices of the shared edge were calculated on Line~\ref{line:shared_edge}, this operation runs in $\mathbb{O}(1)$ time. On Line~\ref{line:multi_cut_space}, a cut space is calculated similarly to Algorithm~\ref{alg:optimal_cut}. Efficient $\mathbb{O}(m+n)$ algorithms for computing a visibility polygon exist such as one in~\cite{el1981linear}. The sampling step on Line~\ref{line:sample_cut_space} computes $K$ samples on the cut space. This operation is simple given a line segment. Hence, this operation has to be performed in $\mathbb{O}(m+n)$ time in the worst case, potentially on every edge of a combined polygon. On Line~\ref{line:search}, a point on the cut space is found that results in the best cost cut. This operation is performed by performing cuts at every point in the set and computing the metric for both polygons. Followed by choosing a cut with the best cost. The cut can be performed in $\mathbb{O}(m+n)$ time. The metric $\chi$ has to be computed for both polygons in $\mathbb{O}(n^2\log{n}+\frac{\alpha_{\min}}{r}n\log{n})$ if $n>m$. Hence, the whole step can be performed in $\mathbb{O}(K(m+n)(\frac{\alpha_{n,\min}}{r}n^2\log{n})$ time if $n>m$. Finally, the decomposition is modified in constant time. 

Finally, Algorithm~\ref{alg:optimization_procedure} is a recursive re-optimization algorithm. The recursive call in Algorithm~\ref{alg:reopt_recursion} can run as many as $N$ times in the worst case where $N$ is the number of cells in the decomposition. However, it is difficult to determine the number of iterations required for Algorithm~\ref{alg:optimization_procedure} to converge. It is clear that this algorithm converges because only the cut that decrease the maximum pair-wise cost are allowed. As such, the whole adjacent graph is traversed looking for possible improvement cuts. If no such cuts were identified then the algorithm terminates.


\section{Simulations}
\label{section:multi_simulations}

Our decomposition algorithm was implemented in Python. The algorithm was implemented with the help of computational geometry libraries including Shapely~\cite{Shapely:13} and Visilibity\cite{VisiLibity:08}. The heuristic solver GLKH~\cite{helsgaun2000effective} was used as a GTSP solver. Transition costs between segments were computed assuming a Dubins' vehicle model~\cite{dubins1957curves}.

The approach was tested on its ability to improve the existing decomposition with the goal to minimize the maximum cost. Several test shapes of varying complexity were used in simulations. The initial decomposition of the polygons was performed by hand. In all test runs, four robots were used with starting locations usually located at the corners of the polygon. To relate the metric $\chi$ to the actual cost of the coverage path, actual coverage paths are computed for each robot in the team using Algorithm~\ref{alg:min_alt_decomposition}.

Performance figures for the algorithm are shown in Table~\ref{table:decomposition_improvement_max} and Table~\ref{table:decomposition_improvement_deviation}. We compare the improvements in the maximum cost $\chi$ as well as the actual lengths of the coverage paths. This comparison demonstrates that our approach works as intended in minimizing the maximum cost. We also compare the mean absolute deviation of costs over all cells in the decomposition. These figures should show that this approach works by distributing the workload amongst all robots in the team. The lengths of the coverage paths were computed by solving the single agent coverage problem for each robot in the team using the approach introduced in Chapter~\ref{chapter:single_agent_coverage}. We note that the algorithm has improved the maximum value of metric $\chi$ on average by 20\% and the actual length of the coverage path by 24\%. The mean absolute deviation was also reduced by 74.6\% and 70.0\% for metric $\chi$ and path lengths respectively.

\begin{table}
	\centering
	\caption{Improvement to the maximum costs.}
	\label{table:decomposition_improvement_max}
	\begin{tabular}{@{}l rrrrrrr}
		\toprule
		& \multicolumn{3}{c}{Max $\chi$} && \multicolumn{3}{c}{Max Tour Length} \\
		\cmidrule{2-4} \cmidrule{6-8}
		& \multicolumn{1}{c}{Old} & \multicolumn{1}{c}{New} & \multicolumn{1}{c}{\%} & & \multicolumn{1}{c}{Old} & \multicolumn{1}{c}{New} & \multicolumn{1}{c}{\%}  \\
		\cmidrule{1-8}
		Shape 1 & 47.5  & \bf{41.6}  & 12.4\% && 30.7  & \bf{26.0}  & 15.3\% \\
		Shape 2 & 228.1 & \bf{155.3} & 31.9\% && 187.6 & \bf{115.4} & 38.5\% \\
		Shape 3 & 218.8 & \bf{185.0} & 15.4\% && 193.3 & \bf{152.7} & 21.0\% \\
		Shape 4 & 202.5 & \bf{173.2} & 14.5\% && 165.1 & \bf{140.0} & 15.2\% \\
		Shape 5 & 235.0 & \bf{169.5} & 27.9\% && 194.3 & \bf{137.9} & 29.0\% \\
		\bottomrule
	\end{tabular}
\end{table}

\begin{table}
	\centering
	\caption{Improvement to the mean absolute deviation on costs.}
	\label{table:decomposition_improvement_deviation}
	\begin{tabular}{@{}l rrrrrrr}
		\toprule
		& \multicolumn{3}{c}{Deviation $\chi$} && \multicolumn{3}{c}{Deviation Tour Length} \\
		\cmidrule{2-4} \cmidrule{6-8}
		& \multicolumn{1}{c}{Old} & \multicolumn{1}{c}{New} & \multicolumn{1}{c}{\%} & & \multicolumn{1}{c}{Old} & \multicolumn{1}{c}{New} & \multicolumn{1}{c}{\%}  \\
		\cmidrule{1-8}
		Shape 1 & 5.00 & \bf{0.08} & 98.3\% && 4.33 & \bf{0.88} & 79.8\% \\
		Shape 2 & 51.6 & \bf{2.99} & 94.2\% && 49.0 & \bf{0.81} & 98.3\% \\
		Shape 3 & 68.0 & \bf{17.1} & 74.8\% && 63.6 & \bf{18.3} & 71.3\% \\
		Shape 4 & 43.1 & \bf{17.5} & 59.4\% && 39.1 & \bf{19.4} & 50.1\% \\
		Shape 5 & 43.8 & \bf{23.1} & 47.1\% && 41.1 & \bf{19.5} & 52.3\% \\
		\bottomrule
	\end{tabular}
\end{table}


Figure~\ref{fig:decomposition_demo}, Figure~\ref{fig:decomposition_results}, and Figure~\ref{fig:decomposition_results_ii} demonstrates decompositions together with the coverage paths. The assignment of paths to the robot is done with color coding. it should be noted that after re-optimizations, the robots do not necessarily retain their previous color. Initial positions of robots are shown as a thick circle located on the boundary of the polygon. The boundary of cells are shown in dashed gray dashed lines. Furthermore. Algorithm~\ref{alg:min_alt_decomposition} from Chapter~\ref{chapter:single_agent_coverage} may add minimum altitude cuts in each region shown in red lines. The dotes segments of the path represent transitions segments computed using Dubin's vehicle model. Note that these segments do not necessarily indicate the path of the robot but rather show the cost associated with the transition. As such, they may cross the boundary of the polygon. The first column of the figure demonstrates the initial decomposition and the second columns shows the decomposition after the applying our algorithm. It should be noted that due to implementation issues with the computational geometry libraries, cells with holes in them are not supported. 

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_1_orig.pdf}% 
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_1_reopt.pdf}

	\caption{Decomposition results for shape 1. Left:decomposition before re-optimization. Right:decomposition after re-optimization.}
	\label{fig:decomposition_demo}

\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_2_orig.pdf}% 	
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_2_reopt_BETTER.pdf}
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_3_orig_BETTER.pdf}%
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_3_reopt_BETTER.pdf}
	\caption{Decomposition results for shape 2 and 3. First column: decomposition before re-optimization. Second column: after re-optimization.}
	\label{fig:decomposition_results}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_4_orig.pdf}%
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_4_reopt.pdf}
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_5_orig.pdf}%
	\includegraphics[width=0.45\textwidth]{img/chapter_5/ID_5_reopt.pdf}
	\caption{Decomposition results for shape 4 and 5. First column: decomposition before re-optimization. Second column: after re-optimization.}
	\label{fig:decomposition_results_ii}
\end{figure}


\end{document}